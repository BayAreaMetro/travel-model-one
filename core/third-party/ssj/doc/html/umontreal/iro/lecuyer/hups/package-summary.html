<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_29) on Thu Feb 16 14:47:06 EST 2012 -->
<TITLE>
umontreal.iro.lecuyer.hups (Java Libraries for Stochastic Simulation)
</TITLE>

<META NAME="date" CONTENT="2012-02-16">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="umontreal.iro.lecuyer.hups (Java Libraries for Stochastic Simulation)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>SSJ </b><br>V. 2.5.</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../umontreal/iro/lecuyer/gof/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../umontreal/iro/lecuyer/probdist/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?umontreal/iro/lecuyer/hups/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package umontreal.iro.lecuyer.hups
</H2>
<A NAME="SECTION00001000000000000000">
Monte Carlo and quasi-Monte Carlo</A>
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/PointSetIterator.html" title="interface in umontreal.iro.lecuyer.hups">PointSetIterator</A></B></TD>
<TD>Objects of classes that implement this interface are <SPAN  CLASS="textit">iterators</SPAN> 
 that permit one to enumerate
 (or observe) the successive points of a point set and the successive 
 coordinates of these points.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/PointSetRandomization.html" title="interface in umontreal.iro.lecuyer.hups">PointSetRandomization</A></B></TD>
<TD>This interface is used to randomize a
 <A HREF="../../../../umontreal/iro/lecuyer/hups/PointSet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>PointSet</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/Randomization.html" title="interface in umontreal.iro.lecuyer.hups">Randomization</A></B></TD>
<TD><B>Deprecated.</B></TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/AntitheticPointSet.html" title="class in umontreal.iro.lecuyer.hups">AntitheticPointSet</A></B></TD>
<TD>This container class provides antithetic points.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/BakerTransformedPointSet.html" title="class in umontreal.iro.lecuyer.hups">BakerTransformedPointSet</A></B></TD>
<TD>This container class embodies a point set to which a
 <SPAN  CLASS="textit">Baker transformation</SPAN> is applied.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/CachedPointSet.html" title="class in umontreal.iro.lecuyer.hups">CachedPointSet</A></B></TD>
<TD>This container class caches a point set by precomputing
 and storing its points locally in an array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/ContainerPointSet.html" title="class in umontreal.iro.lecuyer.hups">ContainerPointSet</A></B></TD>
<TD>This acts as a generic base class for all <SPAN  CLASS="textit">container
 classes</SPAN> that contain a point set and apply some kind of
 transformation to the coordinates to define a new point set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/CycleBasedPointSet.html" title="class in umontreal.iro.lecuyer.hups">CycleBasedPointSet</A></B></TD>
<TD>This abstract class provides the basic structures for
 storing and manipulating a <SPAN  CLASS="textit">highly uniform point set</SPAN>
  defined by a set of cycles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/CycleBasedPointSetBase2.html" title="class in umontreal.iro.lecuyer.hups">CycleBasedPointSetBase2</A></B></TD>
<TD>Similar to <A HREF="../../../../umontreal/iro/lecuyer/hups/CycleBasedPointSet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>CycleBasedPointSet</CODE></A>, except that the successive
 values in the cycles are stored as integers in the range
 
 <SPAN CLASS="MATH">{0,..., 2<SUP>k</SUP> -1}</SPAN>, where 
 <SPAN CLASS="MATH">1&nbsp;&lt;=&nbsp;<I>k</I>&nbsp;&lt;=&nbsp;31</SPAN>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/DigitalNet.html" title="class in umontreal.iro.lecuyer.hups">DigitalNet</A></B></TD>
<TD>This class provides the basic structures for storing and
 manipulating <SPAN  CLASS="textit">linear digital nets in base <SPAN CLASS="MATH"><I>b</I></SPAN></SPAN>, for an arbitrary
 base <SPAN CLASS="MATH"><I>b</I>&nbsp;&gt;=&nbsp;2</SPAN>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/DigitalNetBase2.html" title="class in umontreal.iro.lecuyer.hups">DigitalNetBase2</A></B></TD>
<TD>A special case of <A HREF="../../../../umontreal/iro/lecuyer/hups/DigitalNet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>DigitalNet</CODE></A> for the base <SPAN CLASS="MATH"><I>b</I> = 2</SPAN>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/DigitalNetBase2FromFile.html" title="class in umontreal.iro.lecuyer.hups">DigitalNetBase2FromFile</A></B></TD>
<TD>This class allows us to read the parameters defining a digital net 
  <EM>in base 2</EM> either from a file, or from a URL address on the
  World Wide Web.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/DigitalNetFromFile.html" title="class in umontreal.iro.lecuyer.hups">DigitalNetFromFile</A></B></TD>
<TD>This class allows us to read the parameters defining a digital net either
 from a file, or from a URL address on the World Wide Web.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/DigitalSequence.html" title="class in umontreal.iro.lecuyer.hups">DigitalSequence</A></B></TD>
<TD>This abstract class describes methods specific to digital sequences.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/DigitalSequenceBase2.html" title="class in umontreal.iro.lecuyer.hups">DigitalSequenceBase2</A></B></TD>
<TD>This abstract class describes methods specific to digital sequences in base 2.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/EmptyRandomization.html" title="class in umontreal.iro.lecuyer.hups">EmptyRandomization</A></B></TD>
<TD>This class implements an empty
 <A HREF="../../../../umontreal/iro/lecuyer/hups/PointSetRandomization.html" title="interface in umontreal.iro.lecuyer.hups"><CODE>PointSetRandomization</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/F2wCycleBasedLFSR.html" title="class in umontreal.iro.lecuyer.hups">F2wCycleBasedLFSR</A></B></TD>
<TD>This class creates a point set based upon a linear feedback shift register
  sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/F2wCycleBasedPolyLCG.html" title="class in umontreal.iro.lecuyer.hups">F2wCycleBasedPolyLCG</A></B></TD>
<TD>This class creates a point set based upon
 a linear congruential sequence in the finite field
  
 <SPAN CLASS="MATH"><B>F</B><SUB>2<SUP>w</SUP></SUB>[<I>z</I>]/<I>P</I>(<I>z</I>)</SPAN>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/F2wNetLFSR.html" title="class in umontreal.iro.lecuyer.hups">F2wNetLFSR</A></B></TD>
<TD>This class implements a digital net in base 2 starting from a
 linear feedback shift register generator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/F2wNetPolyLCG.html" title="class in umontreal.iro.lecuyer.hups">F2wNetPolyLCG</A></B></TD>
<TD>This class implements a digital net in base 2 starting from a
 polynomial LCG in 
 <SPAN CLASS="MATH"><B>F</B><SUB>2<SUP>w</SUP></SUB>[<I>z</I>]/<I>P</I>(<I>z</I>)</SPAN>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/F2wStructure.html" title="class in umontreal.iro.lecuyer.hups">F2wStructure</A></B></TD>
<TD>This class implements methods and fields needed by the classes
  <A HREF="../../../../umontreal/iro/lecuyer/hups/F2wNetLFSR.html" title="class in umontreal.iro.lecuyer.hups"><CODE>F2wNetLFSR</CODE></A>,
  <A HREF="../../../../umontreal/iro/lecuyer/hups/F2wNetPolyLCG.html" title="class in umontreal.iro.lecuyer.hups"><CODE>F2wNetPolyLCG</CODE></A>,
  <A HREF="../../../../umontreal/iro/lecuyer/hups/F2wCycleBasedLFSR.html" title="class in umontreal.iro.lecuyer.hups"><CODE>F2wCycleBasedLFSR</CODE></A> and
  <A HREF="../../../../umontreal/iro/lecuyer/hups/F2wCycleBasedPolyLCG.html" title="class in umontreal.iro.lecuyer.hups"><CODE>F2wCycleBasedPolyLCG</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/FaureSequence.html" title="class in umontreal.iro.lecuyer.hups">FaureSequence</A></B></TD>
<TD>This class implements digital nets or digital sequences formed by the
  first <SPAN CLASS="MATH"><I>n</I> = <I>b</I><SUP>k</SUP></SPAN> points of the Faure sequence in base <SPAN CLASS="MATH"><I>b</I></SPAN>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/HaltonSequence.html" title="class in umontreal.iro.lecuyer.hups">HaltonSequence</A></B></TD>
<TD>This class implements the sequence of Halton,
 which is essentially a modification of Hammersley nets for producing 
 an infinite sequence of points having low discrepancy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/HammersleyPointSet.html" title="class in umontreal.iro.lecuyer.hups">HammersleyPointSet</A></B></TD>
<TD>This class implements <SPAN  CLASS="textit">Hammersley point sets</SPAN>, 
 which are defined as follows.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/KorobovLattice.html" title="class in umontreal.iro.lecuyer.hups">KorobovLattice</A></B></TD>
<TD>This class implements <SPAN  CLASS="textit">Korobov lattices</SPAN>, which represents the same point
 sets as in class <A HREF="../../../../umontreal/iro/lecuyer/hups/LCGPointSet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>LCGPointSet</CODE></A>, but implemented differently.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/KorobovLatticeSequence.html" title="class in umontreal.iro.lecuyer.hups">KorobovLatticeSequence</A></B></TD>
<TD>This class implements Korobov lattice sequences, defined as follows.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/LCGPointSet.html" title="class in umontreal.iro.lecuyer.hups">LCGPointSet</A></B></TD>
<TD>Implements a recurrence-based point set defined via a linear 
 congruential recurrence of the form 
 <SPAN CLASS="MATH"><I>x</I><SUB>i</SUB> = <I>ax</I><SUB>i-1</SUB>mod&nbsp;<I>n</I></SPAN>
 and 
 <SPAN CLASS="MATH"><I>u</I><SUB>i</SUB> = <I>x</I><SUB>i</SUB>/<I>n</I></SPAN>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/LMScrambleShift.html" title="class in umontreal.iro.lecuyer.hups">LMScrambleShift</A></B></TD>
<TD>This class implements a
 <A HREF="../../../../umontreal/iro/lecuyer/hups/PointSetRandomization.html" title="interface in umontreal.iro.lecuyer.hups"><CODE>PointSetRandomization</CODE></A>
 that performs a left matrix scrambling and adds a random digital
 shift.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/NiedSequenceBase2.html" title="class in umontreal.iro.lecuyer.hups">NiedSequenceBase2</A></B></TD>
<TD>This class implements digital sequences constructed from the
 Niederreiter sequence in base 2.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/NiedXingSequenceBase2.html" title="class in umontreal.iro.lecuyer.hups">NiedXingSequenceBase2</A></B></TD>
<TD>This class implements digital sequences based on the
  Niederreiter-Xing sequence in base 2.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/PaddedPointSet.html" title="class in umontreal.iro.lecuyer.hups">PaddedPointSet</A></B></TD>
<TD>This container class realizes <SPAN  CLASS="textit">padded point sets</SPAN>, constructed
 by taking some coordinates from a point set <SPAN CLASS="MATH"><I>P</I><SUB>1</SUB></SPAN>, other coordinates
 from a point set <SPAN CLASS="MATH"><I>P</I><SUB>2</SUB></SPAN>, and so on.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/PointSet.html" title="class in umontreal.iro.lecuyer.hups">PointSet</A></B></TD>
<TD>This abstract class defines the basic methods
 for accessing and manipulating point sets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/RadicalInverse.html" title="class in umontreal.iro.lecuyer.hups">RadicalInverse</A></B></TD>
<TD>This class implements basic methods for working with radical
 inverses of integers in an arbitrary basis <SPAN CLASS="MATH"><I>b</I></SPAN>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/RandomShift.html" title="class in umontreal.iro.lecuyer.hups">RandomShift</A></B></TD>
<TD>This class implements a
 <A HREF="../../../../umontreal/iro/lecuyer/hups/PointSetRandomization.html" title="interface in umontreal.iro.lecuyer.hups"><CODE>PointSetRandomization</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/RandomStart.html" title="class in umontreal.iro.lecuyer.hups">RandomStart</A></B></TD>
<TD>This class implements a
 <A HREF="../../../../umontreal/iro/lecuyer/hups/PointSetRandomization.html" title="interface in umontreal.iro.lecuyer.hups"><CODE>PointSetRandomization</CODE></A>
 that randomizes a sequence with a random starting point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/RandShiftedPointSet.html" title="class in umontreal.iro.lecuyer.hups">RandShiftedPointSet</A></B></TD>
<TD>This container class embodies a point set to which a random shift
 modulo 1 is applied (i.e., a single uniform random point is added
 to all points, modulo 1, to randomize the inner point set).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/Rank1Lattice.html" title="class in umontreal.iro.lecuyer.hups">Rank1Lattice</A></B></TD>
<TD>This class implements point sets defined by integration
 lattices of rank 1, defined as follows.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/SMScrambleShift.html" title="class in umontreal.iro.lecuyer.hups">SMScrambleShift</A></B></TD>
<TD>This class implements a
 <A HREF="../../../../umontreal/iro/lecuyer/hups/PointSetRandomization.html" title="interface in umontreal.iro.lecuyer.hups"><CODE>PointSetRandomization</CODE></A>
 that performs a striped matrix scrambling and adds a random
 digital shift.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/SobolSequence.html" title="class in umontreal.iro.lecuyer.hups">SobolSequence</A></B></TD>
<TD>This class implements digital nets or digital sequences in base 2 formed by
  the first <SPAN CLASS="MATH"><I>n</I> = 2<SUP>k</SUP></SPAN> points of a Sobol' sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../umontreal/iro/lecuyer/hups/SubsetOfPointSet.html" title="class in umontreal.iro.lecuyer.hups">SubsetOfPointSet</A></B></TD>
<TD>This container class permits one to select a subset of a point set.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package umontreal.iro.lecuyer.hups Description
</H2>

<P>
<H2><A NAME="SECTION00001000000000000000">
Monte Carlo and quasi-Monte Carlo</A>
</H2>

<P>
This package provides classes implementing <SPAN  CLASS="textit">highly uniform point sets</SPAN>
(HUPS) over the <SPAN CLASS="MATH"><I>s</I></SPAN>-dimensional unit hypercube <SPAN CLASS="MATH">[0, 1)<SUP>s</SUP></SPAN>,
and tools for their randomization.
The terminology <SPAN  CLASS="textit">low-discrepancy sequence</SPAN> (LDS) is often used
for infinite sequences of points such that the <SPAN  CLASS="textit">discrepancy</SPAN>
between the distribution of the first <SPAN CLASS="MATH"><I>n</I></SPAN> points of the sequence and
the uniform distribution converges to zero at a certain rate
when <!-- MATH
 $n\to\infty$
 -->
<SPAN CLASS="MATH"><I>n</I>&nbsp;-&gt;&nbsp;&#8734;</SPAN>.
HUPS and LDS are used for quasi-Monte Carlo integration,
as we now briefly explain.
See, e.g.,
for further details.

<P>
Suppose we want to estimate the integral of a function <SPAN CLASS="MATH"><I>f</I></SPAN> defined over
the <SPAN CLASS="MATH"><I>s</I></SPAN>-dimensional unit hypercube,
<!-- MATH
 \begin{displaymath}
\mu = \htint_{[0,1)^s}\   f(\mbox{\boldmath$u$}) d\mbox{\boldmath$u$}.
\end{displaymath}
 -->
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><A NAME="eq:mu"></A>
<I>&#956;</I> = &int;<SUB>[0, 1)<SUP>s</SUP></SUB>&nbsp;<I>f</I> (<IMG
 ALIGN="MIDDLE" BORDER="0" SRC="overviewimg1.png"
 ALT="$\displaystyle \mbox{\boldmath$u$}$">)<I>d</I>[tex2html_wrap_indisplay1030].
</DIV><P></P>
Practically any mathematical expectation that can be estimated by
simulation can be written in this way, usually for a very complicated
<SPAN CLASS="MATH"><I>f</I></SPAN> and sometimes for <SPAN CLASS="MATH"><I>s</I> = &#8734;</SPAN>.
Indeed, the source of randomness of stochastic simulations
is usually a <SPAN  CLASS="textit">stream</SPAN> of real numbers <!-- MATH
 $\mbox{\boldmath $u$}= (u_0,u_1,u_2,\dots)$
 -->
<SPAN CLASS="MATH"><SPAN CLASS="MATH"><B><I>u</I></B></SPAN> = (<I>u</I><SUB>0</SUB>, <I>u</I><SUB>1</SUB>, <I>u</I><SUB>2</SUB>,...)</SPAN>
whose purpose is to imitate i.i.d. <SPAN CLASS="MATH"><B><I>U</I>(0, 1)</B></SPAN> random variables.
These real numbers are transformed in complicated ways to produce
the estimator.  Thus, the dimension <SPAN CLASS="MATH"><B><I>s</I></B></SPAN> of the integral
represents the number of calls to the uniform random number generator
if that number is deterministic.
If it is random and unbounded, we take <!-- MATH
 $s = \infty$
 -->
<SPAN CLASS="MATH"><B><I>s</I> = &#8734;</B></SPAN>.
In the latter case, however, we can assume that the <SPAN  CLASS="textit">actual</SPAN>
number of calls is finite with probability one (otherwise the simulation
may never end).

<P>
We consider an estimator of <SPAN CLASS="MATH"><B><I>&#956;</I></B></SPAN> of the form
<!-- MATH
 \begin{displaymath}
Q_n = \frac{1}{n} \htsum_{i=0}^{n-1} f(\mbox{\boldmath$u$}_i),
\end{displaymath}
 -->
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><A NAME="eq:Qn"></A>
<B><I>Q</I><SUB>n</SUB> = <IMG
 ALIGN="MIDDLE" BORDER="0" SRC="overviewimg2.png"
 ALT="$\displaystyle {\frac{{1}}{{n}}}$">&sum;<SUB>i=0</SUB><SUP>n-1</SUP><I>f</I> ([tex2html_wrap_indisplay1043]<SUB>i</SUB>),</B>
</DIV><P></P>
which is the average of <SPAN CLASS="MATH"><B><I>f</I></B></SPAN> over the <SPAN  CLASS="textit">point set</SPAN>
<!-- MATH
 $P_n = \{\mbox{\boldmath $u$}_0,\dots,\mbox{\boldmath $u$}_{n-1}\} \subset [0,1)^s$
 -->
<SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB> = {<SPAN CLASS="MATH"><B><I>u</I></B></SPAN><SUB>0</SUB>,...,<SPAN CLASS="MATH"><B><I>u</I></B></SPAN><SUB>n-1</SUB>}&#8834;[0, 1)<SUP>s</SUP></B></SPAN>.

<P>
With the <SPAN  CLASS="textit">Monte Carlo</SPAN> (MC) method, the <!-- MATH
 $\mbox{\boldmath $u$}_i$
 -->
<SPAN CLASS="MATH"><B><SPAN CLASS="MATH"><B><I>u</I></B></SPAN><SUB>i</SUB></B></SPAN>'s are
i.i.d. random vectors uniformly distributed over <SPAN CLASS="MATH"><B>[0, 1)<SUP>s</SUP></B></SPAN>.
Then, <SPAN CLASS="MATH"><B><I>Q</I><SUB>n</SUB></B></SPAN> is an unbiased estimator of <SPAN CLASS="MATH"><B><I>&#956;</I></B></SPAN> with variance
<!-- MATH
 $\sigma^2/n$
 -->
<SPAN CLASS="MATH"><B><I>&#963;</I><SUP>2</SUP>/<I>n</I></B></SPAN>, where
<!-- MATH
 \begin{displaymath}
\sigma^2 = \htint_{[0,1)^s} f^2(\mbox{\boldmath$u$}) d\mbox{\boldmath$u$}- \mu^2,
\end{displaymath}
 -->
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<B><I>&#963;</I><SUP>2</SUP> = &int;<SUB>[0, 1)<SUP>s</SUP></SUB><I>f</I><SUP>2</SUP>([tex2html_wrap_indisplay1061])<I>d</I>[tex2html_wrap_indisplay1062] - <I>&#956;</I><SUP>2</SUP>,</B>
</DIV><P></P>
and it obeys a central-limit theorem if <!-- MATH
 $\sigma^2 < \infty$
 -->
<SPAN CLASS="MATH"><B><I>&#963;</I><SUP>2</SUP> &lt; &#8734;</B></SPAN>.

<P>
<SPAN  CLASS="textit">Quasi-Monte Carlo</SPAN> (QMC) methods use point sets <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN>
that are <SPAN  CLASS="textit">more evenly distributed</SPAN> over the unit hypercube
than typical random points.
We call them <SPAN  CLASS="textit">highly uniform point sets</SPAN> (HUPS).
The aim is to reduce the size of the integration error <SPAN CLASS="MATH"><B><I>Q</I><SUB>n</SUB> - <I>&#956;</I></B></SPAN>.
Two important classes of methods for constructing such point sets are
<SPAN  CLASS="textit">digital nets</SPAN> and <SPAN  CLASS="textit">integration lattices</SPAN>.
Both are implemented in this package, in various flavors.

<P>

<H2><A NAME="SECTION00002000000000000000">
Elementary constructions</A>
</H2>

<P>
To give an idea of how HUPS and LDS can be constructed, we start with
a simple one-dimensional example.
If <SPAN CLASS="MATH"><B><I>s</I> = 1</B></SPAN> and <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> is fixed, very simple highly uniform constructions are
the point sets <!-- MATH
 $P_n = \{0,\, 1/n,\, \dots, (n-1)/n\}$
 -->
<SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB> = {0,&nbsp;1/<I>n</I>,&nbsp;...,(<I>n</I> - 1)/<I>n</I>}</B></SPAN> and
the shifted version <!-- MATH
 $P'_n = \{1/(2n),\, 3/(2n),\, \dots, (2n-1)/(2n)\}$
 -->
<SPAN CLASS="MATH"><B><I>P'</I><SUB>n</SUB> = {1/(2<I>n</I>),&nbsp;3/(2<I>n</I>),&nbsp;...,(2<I>n</I> - 1)/(2<I>n</I>)}</B></SPAN>.

<P>
In <SPAN CLASS="MATH"><B><I>s</I> &gt; 1</B></SPAN> dimensions, the simplest extensions would be as follows.
Let <SPAN CLASS="MATH"><B><I>n</I> = <I>d</I><SUP>s</SUP></B></SPAN> for some integer <SPAN CLASS="MATH"><B><I>d</I></B></SPAN> and define <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN> as the
Cartesian product of <SPAN CLASS="MATH"><B><I>s</I></B></SPAN> copies of the one-dimensional sets <SPAN CLASS="MATH"><B><I>P</I><SUB>d</SUB></B></SPAN>;
that is, <!-- MATH
 $P_n = \{(u_0,\dots,u_{s-1}) :
u_j \in \{0,\, 1/d,\, \dots, (d-1)/d\}$
 -->
<SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB> = {(<I>u</I><SUB>0</SUB>,..., <I>u</I><SUB>s-1</SUB>) : <I>u</I><SUB>j</SUB>&#8712;{0,&nbsp;1/<I>d</I>,&nbsp;...,(<I>d</I> - 1)/<I>d</I>}</B></SPAN> for each <SPAN CLASS="MATH"><B><I>j</I>}</B></SPAN>,
and similarly for <SPAN CLASS="MATH"><B><I>P'</I><SUB>n</SUB></B></SPAN>.
The point sets thus obtained are regular rectangular grids.
Unfortunately, this approach breaks down rapidly when <SPAN CLASS="MATH"><B><I>s</I></B></SPAN> gets large,
because <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> must increase exponentially fast with <SPAN CLASS="MATH"><B><I>s</I></B></SPAN> for fixed <SPAN CLASS="MATH"><B><I>d</I></B></SPAN>.
Another important drawback is that when <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN> is projected over
lower-dimensional subspaces, several points are projected onto each other
and become redundant.

<P>
A better idea is to construct a point set <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN> in <SPAN CLASS="MATH"><B><I>s</I></B></SPAN> dimensions
such that each one-dimensional projection of <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN> is the set
of values <!-- MATH
 $\{0,\, 1/n,\, \dots, (n-1)/n\}$
 -->
<SPAN CLASS="MATH"><B>{0,&nbsp;1/<I>n</I>,&nbsp;...,(<I>n</I> - 1)/<I>n</I>}</B></SPAN>.
Of course, these values should not be visited in the same order for
all coordinates, because otherwise all the points would lie on the
diagonal line going from <!-- MATH
 $(0,\dots,0)$
 -->
<SPAN CLASS="MATH"><B>(0,..., 0)</B></SPAN> to <!-- MATH
 $(1,\dots,1)$
 -->
<SPAN CLASS="MATH"><B>(1,..., 1)</B></SPAN>.
In other words, for each coordinate <SPAN CLASS="MATH"><B><I>j</I></B></SPAN>, <!-- MATH
 $0\le j < s$
 -->
<SPAN CLASS="MATH"><B>0&nbsp;&lt;=&nbsp;<I>j</I> &lt; <I>s</I></B></SPAN>, we must define
a different <SPAN  CLASS="textit">permutation</SPAN> of the integers <!-- MATH
 $\{0,\dots,n-1\}$
 -->
<SPAN CLASS="MATH"><B>{0,..., <I>n</I> - 1}</B></SPAN> and
visit the values <!-- MATH
 $\{0,\, 1/n,\, \dots, (n-1)/n\}$
 -->
<SPAN CLASS="MATH"><B>{0,&nbsp;1/<I>n</I>,&nbsp;...,(<I>n</I> - 1)/<I>n</I>}</B></SPAN> in the order determined
by that permutation.  The trick is to select those permutations in a
way that <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN> itself is highly uniform over <SPAN CLASS="MATH"><B>[0, 1)<SUP>s</SUP></B></SPAN> in a well-defined
sense (to be determined).
This is what most construction methods attempt to achieve.
Before looking at concrete ways of defining such permutations,
we introduce a related issue: what to do if <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> is not fixed.

<P>
For <SPAN CLASS="MATH"><B><I>s</I> = 1</B></SPAN>, a simple way of filling up the unit interval <SPAN CLASS="MATH"><B>[0, 1)</B></SPAN>
uniformly is via the low-discrepancy sequence
0, 1/2, 1/4, 3/4, 1/8, 5/8, 3/8, 7/8, 1/16, 9/16, ...,
called the <SPAN  CLASS="textit">van der Corput sequence</SPAN> in base 2.
More generally, select an integer <SPAN CLASS="MATH"><B><I>b</I>&nbsp;&gt;=&nbsp;2</B></SPAN>, called the <SPAN  CLASS="textit">base</SPAN>.
The <SPAN  CLASS="textit">radical inverse</SPAN> function in base <SPAN CLASS="MATH"><B><I>b</I></B></SPAN>, <!-- MATH
 $\psi_b : \NN\to[0,1)$
 -->
<SPAN CLASS="MATH"><B><I>&#968;</I><SUB>b</SUB> : <B>N</B>&nbsp;-&gt;&nbsp;[0, 1)</B></SPAN>,
is defined as follows.  If <SPAN CLASS="MATH"><B><I>i</I></B></SPAN> is a <SPAN CLASS="MATH"><B><I>k</I></B></SPAN>-digit integer in base <SPAN CLASS="MATH"><B><I>b</I></B></SPAN>
with digital <SPAN CLASS="MATH"><B><I>b</I></B></SPAN>-ary expansion
<!-- MATH
 \begin{displaymath}
i = a_0 + a_1 b + \dots + a_{k-1} b^{k-1},
\end{displaymath}
 -->
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<B><I>i</I> = <I>a</I><SUB>0</SUB> + <I>a</I><SUB>1</SUB><I>b</I> + ... + <I>a</I><SUB>k-1</SUB><I>b</I><SUP>k-1</SUP>,</B>
</DIV><P></P>
then
<!-- MATH
 \begin{displaymath}
\psi_b(i) = a_0 b^{-1} + a_1 b^{-2} + \cdots + a_{k-1} b^{-k}.
\end{displaymath}
 -->
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<B><I>&#968;</I><SUB>b</SUB>(<I>i</I>) = <I>a</I><SUB>0</SUB><I>b</I><SUP>-1</SUP> + <I>a</I><SUB>1</SUB><I>b</I><SUP>-2</SUP> + <SUP> ... </SUP> + <I>a</I><SUB>k-1</SUB><I>b</I><SUP>-k</SUP>.</B>
</DIV><P></P>
For a given <SPAN CLASS="MATH"><B><I>b</I></B></SPAN>, <!-- MATH
 $\psi_b(0), \psi_b(1), \psi_b(2), \dots$
 -->
<SPAN CLASS="MATH"><B><I>&#968;</I><SUB>b</SUB>(0), <I>&#968;</I><SUB>b</SUB>(1), <I>&#968;</I><SUB>b</SUB>(2),...</B></SPAN>
is called the <SPAN  CLASS="textit">van der Corput sequence in base <SPAN CLASS="MATH"><B><I>b</I></B></SPAN></SPAN>.
This sequence fills up the unit interval <SPAN CLASS="MATH"><B>[0, 1)</B></SPAN> quite uniformly.
For example, for <SPAN CLASS="MATH"><B><I>b</I> = 2</B></SPAN> we obtain the sequence mentioned above
and for <SPAN CLASS="MATH"><B><I>b</I> = 3</B></SPAN> we obtain
0, 1/3, 2/3, 1/9, 4/9, 7/9, 2/9, 5/9, 8/9, 1/27, 10/27, 19/27, ....
Moreover, for two relatively prime bases <SPAN CLASS="MATH"><B><I>b</I><SUB>1</SUB></B></SPAN> and <SPAN CLASS="MATH"><B><I>b</I><SUB>2</SUB></B></SPAN>, the two
sequences have no value in common except 0.

<P>
For <SPAN CLASS="MATH"><B><I>s</I> &gt; 1</B></SPAN>, one could either take different (relatively prime)
bases for the different coordinates, or take the same basis <SPAN CLASS="MATH"><B><I>b</I></B></SPAN>
but permute the successive values using a different permutation for
each coordinate.   These permutations are usually selected in a way
that for every integer <SPAN CLASS="MATH"><B><I>k</I></B></SPAN>, the first <SPAN CLASS="MATH"><B><I>b</I><SUP>k</SUP></B></SPAN> values that are
enumerated remain the same (they are the values
of <SPAN CLASS="MATH"><B><I>&#968;</I><SUB>b</SUB>(<I>i</I>)</B></SPAN> for <!-- MATH
 $i=0,\dots,b^k-1$
 -->
<SPAN CLASS="MATH"><B><I>i</I> = 0,..., <I>b</I><SUP>k</SUP> - 1</B></SPAN>), but they are enumerated in a
different order.  Several digital net constructions (to be defined later)
fit this framework.

<P>
If we decide to take different bases, the most natural choice is to
take the <SPAN CLASS="MATH"><B><I>j</I></B></SPAN>th smallest prime, <SPAN CLASS="MATH"><B><I>b</I><SUB>j</SUB></B></SPAN>, as a base for coordinate <SPAN CLASS="MATH"><B><I>j</I> - 1</B></SPAN>;
that is, base 2 for coordinate 0, base 3 for coordinate 1,
base 5 for coordinate 2, and so on.
The infinite sequence thus defined, where point <SPAN CLASS="MATH"><B><I>i</I></B></SPAN> is
<!-- MATH
 \begin{displaymath}
\mbox{\boldmath$u$}_i = (\psi_{b_1}(i),\psi_{b_2}(i),\dots, \psi_{b_{s}}(i))
                                            \eqlabel{eq:Halton-point}
\end{displaymath}
 -->
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<B>[tex2html_wrap_indisplay1128]<SUB>i</SUB> = (<I>&#968;</I><SUB>b<SUB>1</SUB></SUB>(<I>i</I>), <I>&#968;</I><SUB>b<SUB>2</SUB></SUB>(<I>i</I>),..., <I>&#968;</I><SUB>b<SUB>s</SUB></SUB>(<I>i</I>))</B>
</DIV><P></P>
for <SPAN CLASS="MATH"><B><I>i</I>&nbsp;&gt;=&nbsp; 0</B></SPAN>, was proposed in and is called
the <SPAN  CLASS="textit">Halton sequence</SPAN>.
One drawback of this sequence is that for large <SPAN CLASS="MATH"><B><I>s</I></B></SPAN>, the base <SPAN CLASS="MATH"><B><I>b</I><SUB>s</SUB></B></SPAN>
becomes quite large.

<P>
In the case where <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> is fixed,
we can always take <SPAN CLASS="MATH"><B><I>i</I>/<I>n</I></B></SPAN> as the first coordinate of point <SPAN CLASS="MATH"><B><I>i</I></B></SPAN>.
In particular, the <SPAN  CLASS="textit">Hammersley point set</SPAN> with <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> points
in <SPAN CLASS="MATH"><B><I>s</I></B></SPAN> dimensions contains the points
<!-- MATH
 \begin{displaymath}
\mbox{\boldmath$u$}_i = (i/n,\psi_{b_1}(i),\psi_{b_2}(i),\dots, \psi_{b_{s-1}}(i)),
                                            \eqlabel{eq:Hammersley-point}
\end{displaymath}
 -->
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<B>[tex2html_wrap_indisplay1138]<SUB>i</SUB> = (<I>i</I>/<I>n</I>, <I>&#968;</I><SUB>b<SUB>1</SUB></SUB>(<I>i</I>), <I>&#968;</I><SUB>b<SUB>2</SUB></SUB>(<I>i</I>),..., <I>&#968;</I><SUB>b<SUB>s-1</SUB></SUB>(<I>i</I>)),</B>
</DIV><P></P>
for <!-- MATH
 $i=0,\dots,n-1$
 -->
<SPAN CLASS="MATH"><B><I>i</I> = 0,..., <I>n</I> - 1</B></SPAN>.
Historically, Halton sequences were defined as extensions of
Hammersley point sets.

<P>

<H2><A NAME="SECTION00003000000000000000">
Digital nets</A>
</H2>

<P>
<SPAN  CLASS="textit">Digital nets and sequences</SPAN> are an important class of HUPS
and LDS constructions.
Most concrete implementations, e.g., those proposed by
Sobol', Faure, Niederreiter, and Niederreiter and Xing,
are <SPAN  CLASS="textit">linear</SPAN> digital nets and sequences, defined as follows
(see also).

<P>
Let <SPAN CLASS="MATH"><B><I>b</I>&nbsp;&gt;=&nbsp;2</B></SPAN> be an arbitrary integer (usually a prime number), called
the <SPAN  CLASS="textit">base</SPAN>.
A net that contains <SPAN CLASS="MATH"><B><I>n</I> = <I>b</I><SUP>k</SUP></B></SPAN> points in <SPAN CLASS="MATH"><B><I>s</I></B></SPAN> dimensions is defined via
<SPAN CLASS="MATH"><B><I>s</I></B></SPAN> <SPAN  CLASS="textit">generator matrices</SPAN> <!-- MATH
 $\bC_0,\dots,\bC_{s-1}$
 -->
<SPAN CLASS="MATH"><B><B>C</B><SUB>0</SUB>,...,<B>C</B><SUB>s-1</SUB></B></SPAN>, which are
(in theory) <!-- MATH
 $\infty\times k$
 -->
<SPAN CLASS="MATH"><B>&#8734;&#215;<I>k</I></B></SPAN> matrices whose elements are in
<!-- MATH
 $\ZZ_b = \{0,\dots,b-1\}$
 -->
<SPAN CLASS="MATH"><B><B>Z</B><SUB>b</SUB> = {0,..., <I>b</I> - 1}</B></SPAN>.
The matrix <SPAN CLASS="MATH"><B><B>C</B><SUB>j</SUB></B></SPAN> is used for coordinate <SPAN CLASS="MATH"><B><I>j</I></B></SPAN> of all the points, for <SPAN CLASS="MATH"><B><I>j</I>&nbsp;&gt;=&nbsp; 0</B></SPAN>.
To define the <SPAN CLASS="MATH"><B><I>i</I></B></SPAN>th point <!-- MATH
 $\mbox{\boldmath $u$}_i$
 -->
<SPAN CLASS="MATH"><B><SPAN CLASS="MATH"><B><I>u</I></B></SPAN><SUB>i</SUB></B></SPAN>, for <!-- MATH
 $i=0,\dots,b^k-1$
 -->
<SPAN CLASS="MATH"><B><I>i</I> = 0,..., <I>b</I><SUP>k</SUP> - 1</B></SPAN>, write
the digital expansion of <SPAN CLASS="MATH"><B><I>i</I></B></SPAN> in base <SPAN CLASS="MATH"><B><I>b</I></B></SPAN> and multiply the vector of its
digits by <SPAN CLASS="MATH"><B><B>C</B><SUB>j</SUB></B></SPAN> to obtain the digits of the expansion of <SPAN CLASS="MATH"><B><I>u</I><SUB>i, j</SUB></B></SPAN>,
the <SPAN CLASS="MATH"><B><I>j</I></B></SPAN>th coordinate of <!-- MATH
 $\mbox{\boldmath $u$}_i$
 -->
<SPAN CLASS="MATH"><B><SPAN CLASS="MATH"><B><I>u</I></B></SPAN><SUB>i</SUB></B></SPAN>.  That is,

<BR>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{eqnarray*}
i &=& \htsum_{\ell=0}^{k-1} a_{i,\ell} b^\ell,   \eqlabel{eq:digital-i} \\
 \pmatrix{u_{i,j,1}\cr u_{i,j,2}\cr \vdots \cr }
    &=& \bC_j \pmatrix{a_{i,0}\cr a_{i,1}\cr \vdots \cr a_{i,k-1}\cr},
                                                 \eqlabel{eq:digital-Cj} \\
 u_{i,j} &=& \htsum_{\ell=1}^\infty u_{i,j,\ell} b^{-\ell},
                                                 \eqlabel{eq:digital-uij} \\
  \mbox{\boldmath$u$}_i &=& (u_{i,0},\dots,u_{i,s-1}).             \eqlabel{eq:digital-ui}
\end{eqnarray*}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><I>i</I></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP>=</TD>
<TD ALIGN="LEFT" NOWRAP>&sum;<SUB><IMG
 ALIGN="MIDDLE" BORDER="0" SRC="overviewimg3.png"
 ALT="$\scriptstyle \ell$">=0</SUB><SUP>k-1</SUP><I>a</I><SUB>i,[tex2html_wrap_indisplay1174]</SUB><I>b</I><SUP>[tex2html_wrap_indisplay1175]</SUP>,</TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG
 ALIGN="BOTTOM" BORDER="0" SRC="overviewimg4.png"
 ALT="$\displaystyle \pmatrix$"><I>u</I><SUB>i, j, 1</SUB><IMG
 ALIGN="MIDDLE" BORDER="0" SRC="overviewimg5.png"
 ALT="$\displaystyle \cr$"><I>u</I><SUB>i, j, 2</SUB>[tex2html_wrap_indisplay1179] <IMG
 ALIGN="MIDDLE" BORDER="0" SRC="overviewimg6.png"
 ALT="$\displaystyle \vdots$"> [tex2html_wrap_indisplay1181]</TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP>=</TD>
<TD ALIGN="LEFT" NOWRAP><B>C</B><SUB>j</SUB>[tex2html_wrap_indisplay1184]<I>a</I><SUB>i, 0</SUB>[tex2html_wrap_indisplay1185]<I>a</I><SUB>i, 1</SUB>[tex2html_wrap_indisplay1186] [tex2html_wrap_indisplay1187] [tex2html_wrap_indisplay1188]<I>a</I><SUB>i, k-1</SUB>[tex2html_wrap_indisplay1189],</TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><I>u</I><SUB>i, j</SUB></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP>=</TD>
<TD ALIGN="LEFT" NOWRAP>&sum;<SUB>[tex2html_wrap_indisplay1193]=1</SUB><SUP>&#8734;</SUP><I>u</I><SUB>i, j,[tex2html_wrap_indisplay1194]</SUB><I>b</I><SUP>-[tex2html_wrap_indisplay1195]</SUP>,</TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT">[tex2html_wrap_indisplay1197]<SUB>i</SUB></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP>=</TD>
<TD ALIGN="LEFT" NOWRAP>(<I>u</I><SUB>i, 0</SUB>,..., <I>u</I><SUB>i, s-1</SUB>).</TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL">

In practice, the expansion in is truncated to the
first <SPAN CLASS="MATH"><B><I>r</I></B></SPAN> digits for some positive integer <SPAN CLASS="MATH"><B><I>r</I></B></SPAN>, so each matrix <SPAN CLASS="MATH"><B><B>C</B><SUB>j</SUB></B></SPAN> is
actually truncated to a <SPAN CLASS="MATH"><B><I>r</I>&#215;<I>k</I></B></SPAN> matrix.
Typically <SPAN CLASS="MATH"><B><I>r</I></B></SPAN> is equal to <SPAN CLASS="MATH"><B><I>k</I></B></SPAN>, or is slightly larger,
or is selected so that <SPAN CLASS="MATH"><B><I>b</I><SUP>r</SUP></B></SPAN> is near <SPAN CLASS="MATH"><B>2<SUP>31</SUP></B></SPAN>.

<P>
Usually, the first <SPAN CLASS="MATH"><B><I>k</I></B></SPAN> lines of each <SPAN CLASS="MATH"><B><B>C</B><SUB>j</SUB></B></SPAN> form a nonsingular
<SPAN CLASS="MATH"><B><I>k</I>&#215;<I>k</I></B></SPAN> matrix.  Then, the <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> output values for coordinate <SPAN CLASS="MATH"><B><I>j</I></B></SPAN>,
<!-- MATH
 $u_{0,j},\dots, u_{n-1,j}$
 -->
<SPAN CLASS="MATH"><B><I>u</I><SUB>0, j</SUB>,..., <I>u</I><SUB>n-1, j</SUB></B></SPAN>, when truncated to their first <SPAN CLASS="MATH"><B><I>k</I></B></SPAN> fractional
digits in base <SPAN CLASS="MATH"><B><I>b</I></B></SPAN>, are a permutation of the numbers
<!-- MATH
 $0, 1/n, \dots, (n-1)/n$
 -->
<SPAN CLASS="MATH"><B>0, 1/<I>n</I>,...,(<I>n</I> - 1)/<I>n</I></B></SPAN>.
Different coordinates simply use different permutations,
implemented via the matrices <SPAN CLASS="MATH"><B><B>C</B><SUB>j</SUB></B></SPAN>.

<P>
When the first <SPAN CLASS="MATH"><B><I>k</I></B></SPAN> lines of <SPAN CLASS="MATH"><B><B>C</B><SUB>j</SUB></B></SPAN> form the identity and the other
lines are zero, the first <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> output values are the first <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> elements
of the van der Corput sequence in base <SPAN CLASS="MATH"><B><I>b</I></B></SPAN>.
If we reverse the order of the columns of that matrix <SPAN CLASS="MATH"><B><B>C</B><SUB>j</SUB></B></SPAN>
(i.e., column <SPAN CLASS="MATH"><B><I>c</I></B></SPAN> will contain a one in line <SPAN CLASS="MATH"><B><I>k</I> - <I>c</I> + 1</B></SPAN> and zeros elsewhere,
for <!-- MATH
 $0\le c < k$
 -->
<SPAN CLASS="MATH"><B>0&nbsp;&lt;=&nbsp;<I>c</I> &lt; <I>k</I></B></SPAN>), we obtain the output values
<!-- MATH
 $0, 1/n, \dots, (n-1)/n$
 -->
<SPAN CLASS="MATH"><B>0, 1/<I>n</I>,...,(<I>n</I> - 1)/<I>n</I></B></SPAN> in that order.
With a slight abuse of language, we shall call this first matrix
(with the identity followed by lines of zeros) the <SPAN  CLASS="textit">identity</SPAN>
and the second one (with the columns in reverse order) the
<SPAN  CLASS="textit">reflected identity</SPAN>.
It is customary to take <SPAN CLASS="MATH"><B><B>C</B><SUB>0</SUB></B></SPAN> as the identity for digital sequences,
and often for digital nets as well.
But for digital nets (where <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> is fixed in advance),
one can take <SPAN CLASS="MATH"><B><B>C</B><SUB>0</SUB></B></SPAN> as the reflected identity instead,
then <SPAN CLASS="MATH"><B><B>C</B><SUB>1</SUB></B></SPAN> as the identity, and so on.
That is, the matrix <SPAN CLASS="MATH"><B><B>C</B><SUB>j</SUB></B></SPAN> for the digital net is taken as the matrix
<SPAN CLASS="MATH"><B><B>C</B><SUB>j-1</SUB></B></SPAN> of the digital sequence.
Our package often gives the choice.

<P>
For digital sequences, the matrices <SPAN CLASS="MATH"><B><B>C</B><SUB>j</SUB></B></SPAN> actually have an infinite
number of columns, although only the first <SPAN CLASS="MATH"><B><I>k</I></B></SPAN> columns are needed to
generate the first <SPAN CLASS="MATH"><B><I>b</I><SUP>k</SUP></B></SPAN> points.  So in practice, we never need to store
more than a finite number of columns at a time.
Whenever we find that we need more than <SPAN CLASS="MATH"><B><I>b</I><SUP>k</SUP></B></SPAN> points for the current
value of <SPAN CLASS="MATH"><B><I>k</I></B></SPAN>, we can simply increase <SPAN CLASS="MATH"><B><I>k</I></B></SPAN> and add the corresponding
columns to the matrices <SPAN CLASS="MATH"><B><B>C</B><SUB>j</SUB></B></SPAN>.

<P>
The classes <A HREF="../../../../umontreal/iro/lecuyer/hups/DigitalNet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>DigitalNet</CODE></A>
 and <A HREF="../../../../umontreal/iro/lecuyer/hups/DigitalSequence.html" title="class in umontreal.iro.lecuyer.hups"><CODE>DigitalSequence</CODE></A>
implement generic digital nets and sequences.
Specific instances are constructed in subclasses of these two classes.

<P>

<H2><A NAME="SECTION00004000000000000000">
Lattice Rules</A>
</H2>

<P>
An <SPAN  CLASS="textit">integration lattice</SPAN> is a discrete (but infinite)
subset of <SPAN CLASS="MATH"><B><B>R</B><SUP>s</SUP></B></SPAN> of the form
<!-- MATH
 \begin{displaymath}
L_s = \{\bv = \htsum_{j=1}^s h_j {\bv_j}
             \mbox{ such that each } h_j\in\ZZ\},
\end{displaymath}
 -->
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<B><I>L</I><SUB>s</SUB> = {<B>v</B> = &sum;<SUB>j=1</SUB><SUP>s</SUP><I>h</I><SUB>j</SUB><B>v</B><SUB>j</SUB> such that each <I>h</I><SUB>j</SUB>&#8712;<B>Z</B>},</B>
</DIV><P></P>
where <!-- MATH
 $\bv_1,\dots,\bv_s \in \RR^s$
 -->
<SPAN CLASS="MATH"><B><B>v</B><SUB>1</SUB>,...,<B>v</B><SUB>s</SUB>&#8712;<B>R</B><SUP>s</SUP></B></SPAN> are linearly independent over <SPAN CLASS="MATH"><B><B>R</B></B></SPAN>
and <!-- MATH
 $\ZZ^s \subseteq L_s$
 -->
<SPAN CLASS="MATH"><B><B>Z</B><SUP>s</SUP>&#8838;<I>L</I><SUB>s</SUB></B></SPAN>.  This last condition means that
<SPAN CLASS="MATH"><B><I>L</I><SUB>s</SUB></B></SPAN> must contain all integer vectors, and this implies that
<SPAN CLASS="MATH"><B><I>L</I><SUB>s</SUB></B></SPAN> is periodic with period 1 along each of the <SPAN CLASS="MATH"><B><I>s</I></B></SPAN> coordinates.
The approximation of <SPAN CLASS="MATH"><B><I>&#956;</I></B></SPAN> by <SPAN CLASS="MATH"><B><I>Q</I><SUB>n</SUB></B></SPAN> with the point set
<!-- MATH
 $P_n = L_s \cap [0,1)^s$
 -->
<SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB> = <I>L</I><SUB>s</SUB>&#8745;[0, 1)<SUP>s</SUP></B></SPAN> is called a <SPAN  CLASS="textit">lattice rule</SPAN>.  The value of <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> is the number of points
of the lattice that are in the unit hypercube <SPAN CLASS="MATH"><B>[0, 1)<SUP>s</SUP></B></SPAN>.

<P>
Let <SPAN CLASS="MATH"><B><B>V</B></B></SPAN> be the matrix whose rows are the basis vectors
<!-- MATH
 $\bv_1,\cdots,\bv_s$
 -->
<SPAN CLASS="MATH"><B><B>v</B><SUB>1</SUB>,<SUP> ... </SUP>,<B>v</B><SUB>s</SUB></B></SPAN> and <SPAN CLASS="MATH"><B><B>V</B><SUP>-1</SUP></B></SPAN> its inverse.
One has <!-- MATH
 $\ZZ^s\subseteq L_s$
 -->
<SPAN CLASS="MATH"><B><B>Z</B><SUP>s</SUP>&#8838;<I>L</I><SUB>s</SUB></B></SPAN> if and only if
all entries of <SPAN CLASS="MATH"><B><B>V</B><SUP>-1</SUP></B></SPAN> are integer.
When this holds, <!-- MATH
 $n = \det(\bV^{-1})$
 -->
<SPAN CLASS="MATH"><B><I>n</I> = det(<B>V</B><SUP>-1</SUP>)</B></SPAN>
and all entries of <SPAN CLASS="MATH"><B><B>V</B></B></SPAN> are multiples of <SPAN CLASS="MATH"><B>1/<I>n</I></B></SPAN>.

<P>
The <SPAN  CLASS="textit">rank</SPAN> of the lattice is the smallest <SPAN CLASS="MATH"><B><I>r</I></B></SPAN> such that one can
find a basis of the form <!-- MATH
 $\bv_1,\dots, \bv_r,\be_{r+1},\cdots,\be_s$
 -->
<SPAN CLASS="MATH"><B><B>v</B><SUB>1</SUB>,...,<B>v</B><SUB>r</SUB>,<B>e</B><SUB>r+1</SUB>,<SUP> ... </SUP>,<B>e</B><SUB>s</SUB></B></SPAN>,
where <SPAN CLASS="MATH"><B><B>e</B><SUB>j</SUB></B></SPAN> is the <SPAN CLASS="MATH"><B><I>j</I></B></SPAN>th unit vector in <SPAN CLASS="MATH"><B><I>s</I></B></SPAN> dimensions.
In particular, a lattice rule of <SPAN  CLASS="textit">rank 1</SPAN> has a basis of the form
<!-- MATH
 $\bv_1 = (a_1, \dots, a_{s})/n$
 -->
<SPAN CLASS="MATH"><B><B>v</B><SUB>1</SUB> = (<I>a</I><SUB>1</SUB>,..., <I>a</I><SUB>s</SUB>)/<I>n</I></B></SPAN> and <!-- MATH
 $\bv_j = \be_j$
 -->
<SPAN CLASS="MATH"><B><B>v</B><SUB>j</SUB> = <B>e</B><SUB>j</SUB></B></SPAN> for <SPAN CLASS="MATH"><B><I>j</I> &gt; 1</B></SPAN>,
where <!-- MATH
 $a_j \in\ZZ_n$
 -->
<SPAN CLASS="MATH"><B><I>a</I><SUB>j</SUB>&#8712;<B>Z</B><SUB>n</SUB></B></SPAN> for each <SPAN CLASS="MATH"><B><I>j</I></B></SPAN>.
It is a <SPAN  CLASS="textit">Korobov</SPAN> rule if <SPAN CLASS="MATH"><B><B>v</B><SUB>1</SUB></B></SPAN> has the special
form <!-- MATH
 $\bv_1 = (1,\; a,\; a^2 \mod n,\; \dots,\; a^{s-1} \mod n)/n$
 -->
<SPAN CLASS="MATH"><B><B>v</B><SUB>1</SUB> = (1, &nbsp;<I>a</I>, &nbsp;<I>a</I><SUP>2</SUP>mod&nbsp;<I>n</I>, &nbsp;..., &nbsp;<I>a</I><SUP>s-1</SUP>mod&nbsp;<I>n</I>)/<I>n</I></B></SPAN>
for some <SPAN CLASS="MATH"><B><I>a</I>&#8712;<B>Z</B><SUB>n</SUB></B></SPAN>.
The point set <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN> of a Korobov lattice rule can also be written as
<!-- MATH
 $P_n = \{(x_1,\dots,x_s)/n$
 -->
<SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB> = {(<I>x</I><SUB>1</SUB>,..., <I>x</I><SUB>s</SUB>)/<I>n</I></B></SPAN> such that <!-- MATH
 $x_1\in\ZZ_n$
 -->
<SPAN CLASS="MATH"><B><I>x</I><SUB>1</SUB>&#8712;<B>Z</B><SUB>n</SUB></B></SPAN> and
<!-- MATH
 $x_j = a x_{j-1} \mod n$
 -->
<SPAN CLASS="MATH"><B><I>x</I><SUB>j</SUB> = <I>ax</I><SUB>j-1</SUB>mod&nbsp;<I>n</I></B></SPAN> for all <SPAN CLASS="MATH"><B><I>j</I> &gt; 1}</B></SPAN>.  This is the set of all
vectors of successive values produced by a linear congruential generator
(LCG) with modulus <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> and multiplier <SPAN CLASS="MATH"><B><I>a</I></B></SPAN>, from all possible initial
states, including 0.  In this case, the points are easy to enumerate
by using the recurrence.

<P>

<H2><A NAME="SECTION00005000000000000000">
Cycle-based point sets</A>
</H2>

<P>
Certain types of point sets are defined pretty much like random number
generators: choose a finite state space <SPAN CLASS="MATH"><B>S</B></SPAN>, a transition function
<!-- MATH
 $f : \cS\to\cS$
 -->
<SPAN CLASS="MATH"><B><I>f</I> : S&nbsp;-&gt;&nbsp;S</B></SPAN>, an output function <!-- MATH
 $g : \cS\to [0,1)$
 -->
<SPAN CLASS="MATH"><B><I>g</I> : S&nbsp;-&gt;&nbsp;[0, 1)</B></SPAN>, and define
<!-- MATH
 \begin{displaymath}
P_n = \{\mbox{\boldmath$u$}= (u_0,u_1,\dots) : s_0\in\cS,\ s_j = f(s_{j-1}),
               \mbox{ and } u_j = g(s_j) \mbox{ for all } j\}.
\end{displaymath}
 -->
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<B><I>P</I><SUB>n</SUB> = {[tex2html_wrap_indisplay1288] = (<I>u</I><SUB>0</SUB>, <I>u</I><SUB>1</SUB>,...) : <I>s</I><SUB>0</SUB>&#8712;S,&nbsp;<I>s</I><SUB>j</SUB> = <I>f</I> (<I>s</I><SUB>j-1</SUB>), and <I>u</I><SUB>j</SUB> = <I>g</I>(<I>s</I><SUB>j</SUB>) for all <I>j</I>}.</B>
</DIV><P></P>
This is the set of all vectors of successive output values produced
by the recurrence defined by <SPAN CLASS="MATH"><B><I>f</I></B></SPAN> and the output function <SPAN CLASS="MATH"><B><I>g</I></B></SPAN>, from all
possible initial states.
The value of <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> is the cardinality of <SPAN CLASS="MATH"><B>S</B></SPAN> and the dimension <SPAN CLASS="MATH"><B><I>s</I></B></SPAN>
is infinite.  We could also have <!-- MATH
 $n = \infty$
 -->
<SPAN CLASS="MATH"><B><I>n</I> = &#8734;</B></SPAN> (an infinite sequence)
if <SPAN CLASS="MATH"><B>S</B></SPAN> is infinite but denumerable and ordered (so we know in which
order to enumerate the points).

<P>
Let us assume that <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> is finite and that for each <SPAN CLASS="MATH"><B><I>s</I><SUB>0</SUB>&#8712;S</B></SPAN>,
the recurrence <!-- MATH
 $s_j = f(s_{j-1})$
 -->
<SPAN CLASS="MATH"><B><I>s</I><SUB>j</SUB> = <I>f</I> (<I>s</I><SUB>j-1</SUB>)</B></SPAN> is <SPAN  CLASS="textit">purely periodic</SPAN>, i.e.,
there is always an integer <SPAN CLASS="MATH"><B><I>j</I></B></SPAN> such that <SPAN CLASS="MATH"><B><I>s</I><SUB>j</SUB> = <I>s</I><SUB>0</SUB></B></SPAN>.
The smallest such <SPAN CLASS="MATH"><B><I>j</I></B></SPAN>, called the <SPAN  CLASS="textit">period length</SPAN>, depends in
general on <SPAN CLASS="MATH"><B><I>s</I><SUB>0</SUB></B></SPAN>.  Thus, the state space <SPAN CLASS="MATH"><B>S</B></SPAN> is partitioned into a
finite number of <SPAN  CLASS="textit">cycles</SPAN>.  The successive coordinates of any point
<!-- MATH
 $\mbox{\boldmath $u$}\in P_n$
 -->
<SPAN CLASS="MATH"><B><SPAN CLASS="MATH"><B><I>u</I></B></SPAN>&#8712;<I>P</I><SUB>n</SUB></B></SPAN> are periodic with period length equal to the length of the
cycle that contains <SPAN CLASS="MATH"><B><I>s</I><SUB>0</SUB></B></SPAN> (and the following <SPAN CLASS="MATH"><B><I>s</I><SUB>j</SUB></B></SPAN>'s).

<P>
One way of implementing such a point set while avoiding to recompute
<SPAN CLASS="MATH"><B><I>f</I></B></SPAN> and <SPAN CLASS="MATH"><B><I>g</I></B></SPAN> each time a coordinate is needed is to store explicitly
all the cycles of the recurrence, in the form of a <SPAN  CLASS="textit">list of cycles</SPAN>.
We can store either the successive <SPAN CLASS="MATH"><B><I>u</I><SUB>j</SUB></B></SPAN>'s directly, or the successive
<SPAN CLASS="MATH"><B><I>s</I><SUB>j</SUB></B></SPAN>'s, over each cycle.
The class <A HREF="../../../../umontreal/iro/lecuyer/hups/CycleBasedPointSet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>CycleBasedPointSet</CODE></A>
 provides the framework for doing that.

<P>
For example, a Korobov lattice point set is defined via the recurrence
<!-- MATH
 $x_j = a x_{j-1} \mod n$
 -->
<SPAN CLASS="MATH"><B><I>x</I><SUB>j</SUB> = <I>ax</I><SUB>j-1</SUB>mod&nbsp;<I>n</I></B></SPAN> and output function <!-- MATH
 $u_j = x_j/n$
 -->
<SPAN CLASS="MATH"><B><I>u</I><SUB>j</SUB> = <I>x</I><SUB>j</SUB>/<I>n</I></B></SPAN>.
If <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> is prime and <SPAN CLASS="MATH"><B><I>a</I></B></SPAN> is a primitive element modulo <SPAN CLASS="MATH"><B><I>n</I></B></SPAN>, then there
are two cycles: one of period 1 that contains only 0, and
the other of period <SPAN CLASS="MATH"><B><I>n</I> - 1</B></SPAN>.
For more general <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> and <SPAN CLASS="MATH"><B><I>a</I></B></SPAN>, there will be more cycles.
The class  <A HREF="../../../../umontreal/iro/lecuyer/hups/LCGPointSet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>LCGPointSet</CODE></A>
 constructs this type of point set and
stores explicitly the successive values of <SPAN CLASS="MATH"><B><I>u</I><SUB>j</SUB></B></SPAN> over the different cycles.

<P>
There are cases where <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> is a power of two, say <SPAN CLASS="MATH"><B><I>n</I> = 2<SUP>k</SUP></B></SPAN>,
and where the state <SPAN CLASS="MATH"><B><I>s</I><SUB>j</SUB></B></SPAN> is represented as a <SPAN CLASS="MATH"><B><I>k</I></B></SPAN>-bit string.
In that context, it is often more convenient to store the successive
<SPAN CLASS="MATH"><B><I>s</I><SUB>j</SUB></B></SPAN>'s instead of the successive <SPAN CLASS="MATH"><B><I>u</I><SUB>j</SUB></B></SPAN>'s, over the set of cycles
(e.g., if a random digital shift in base 2 is to be applied to
randomize the points, it can be performed by applying a bitwise xor
directly to <SPAN CLASS="MATH"><B><I>s</I><SUB>j</SUB></B></SPAN>).
When generating the coordinates, the <SPAN CLASS="MATH"><B><I>s</I><SUB>j</SUB></B></SPAN>'s can be interpreted as
<SPAN CLASS="MATH"><B>2<SUP>k</SUP></B></SPAN>-bit integers and multiplied by <SPAN CLASS="MATH"><B>2<SUP>-k</SUP></B></SPAN> to produce the output.
This is supported by the class
 <A HREF="../../../../umontreal/iro/lecuyer/hups/CycleBasedPointSetBase2.html" title="class in umontreal.iro.lecuyer.hups"><CODE>CycleBasedPointSetBase2</CODE></A>.
Special instances of this class are usually based on
linear recurrences modulo 2 and they include the Korobov-type
<SPAN  CLASS="textit">polynomial lattice rules</SPAN>.

<P>

<H2><A NAME="SECTION00006000000000000000">
Randomized quasi-Monte Carlo</A>
</H2>

<P>
In their original versions, these HUPS are deterministic, and the
corresponding QMC methods give a <SPAN  CLASS="textit">deterministic</SPAN> integration error
that is difficult to estimate.
In <SPAN  CLASS="textit">randomized</SPAN> QMC methods, <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN> is randomized, preferably in a
way that it retains its high uniformity over <SPAN CLASS="MATH"><B>[0, 1)<SUP>s</SUP></B></SPAN> when taken as a set,
while each of its points has the uniform distribution over <SPAN CLASS="MATH"><B>[0, 1)<SUP>s</SUP></B></SPAN>
when taken individually.  Then, <SPAN CLASS="MATH"><B><I>Q</I><SUB>n</SUB></B></SPAN> becomes an unbiased estimator
of <SPAN CLASS="MATH"><B><I>&#956;</I></B></SPAN>, hopefully with smaller variance than the standard MC estimator.
To estimate the variance and compute a confidence interval on
<SPAN CLASS="MATH"><B><I>&#956;</I></B></SPAN>, one can apply <SPAN CLASS="MATH"><B><I>m</I></B></SPAN> independent randomizations to the same <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN>,
and compute <!-- MATH
 ${\bar X_m}$
 -->
<SPAN CLASS="MATH"><B>bar(X)<SUB>m</SUB></B></SPAN> and <!-- MATH
 ${S_{m,x}^2}$
 -->
<SPAN CLASS="MATH"><B><I>S</I><SUB>m, x</SUB><SUP>2</SUP></B></SPAN>, the sample mean and sample
variance of the <SPAN CLASS="MATH"><B><I>m</I></B></SPAN> corresponding (independent) copies of <SPAN CLASS="MATH"><B><I>Q</I><SUB>n</SUB></B></SPAN>.
Then, <!-- MATH
 $E[\bar X_m] = \mu$
 -->
<SPAN CLASS="MATH"><B><I>E</I>[bar(X)<SUB>m</SUB>] = <I>&#956;</I></B></SPAN> and <!-- MATH
 $E[S_{m,x}^2] = \Var[Q_n] = m\Var[\bar X_m]$
 -->
<SPAN CLASS="MATH"><B><I>E</I>[<I>S</I><SUB>m, x</SUB><SUP>2</SUP>] = Var[<I>Q</I><SUB>n</SUB>] = <I>m</I>Var[bar(X)<SUB>m</SUB>]</B></SPAN>.

<P>
Two examples of such randomizations are the <SPAN  CLASS="textit">random shift modulo 1</SPAN>,
proposed in and implemented in class
<A HREF="../../../../umontreal/iro/lecuyer/hups/RandShiftedPointSet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>RandShiftedPointSet</CODE></A>,
and the <SPAN  CLASS="textit">random digital shift in base <SPAN CLASS="MATH"><B><I>b</I></B></SPAN></SPAN>, described and
implemented in class <A HREF="../../../../umontreal/iro/lecuyer/hups/DigitalNet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>DigitalNet</CODE></A>.
These randomizations are also incorporated directly in certain types
of point sets such as
<A HREF="../../../../umontreal/iro/lecuyer/hups/CycleBasedPointSet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>CycleBasedPointSet</CODE></A>,
<A HREF="../../../../umontreal/iro/lecuyer/hups/CycleBasedPointSetBase2.html" title="class in umontreal.iro.lecuyer.hups"><CODE>CycleBasedPointSetBase2</CODE></A>, etc.

<P>
In the random shift modulo 1, we generate a <SPAN  CLASS="textit">single</SPAN> point <!-- MATH
 $\mbox{\boldmath $u$}$
 -->
<SPAN CLASS="MATH"><B><SPAN CLASS="MATH"><B><I>u</I></B></SPAN></B></SPAN>
uniformly over <SPAN CLASS="MATH"><B>[0, 1)<SUP>s</SUP></B></SPAN> and add it to each point of <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN>,
coordinate-wise, modulo 1.
Since all points of <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN> are shifted by the same amount,
the set retains most of its structure and uniformity.

<P>
For the random digital shift in base <SPAN CLASS="MATH"><B><I>b</I></B></SPAN>, we generate again a single
<!-- MATH
 $\mbox{\boldmath $u$}= (u_1,\dots,u_s)$
 -->
<SPAN CLASS="MATH"><B><SPAN CLASS="MATH"><B><I>u</I></B></SPAN> = (<I>u</I><SUB>1</SUB>,..., <I>u</I><SUB>s</SUB>)</B></SPAN> uniformly over <SPAN CLASS="MATH"><B>[0, 1)<SUP>s</SUP></B></SPAN>,
write the digital expansion in base <SPAN CLASS="MATH"><B><I>b</I></B></SPAN> of each of its coordinates,
say <!-- MATH
 $u_j = \htsum_{\ell=1}^\infty d_{j,\ell} b^{-\ell}$
 -->
<SPAN CLASS="MATH"><B><I>u</I><SUB>j</SUB> = &sum;<SUB>[tex2html_wrap_inline1364]=1</SUB><SUP>&#8734;</SUP><I>d</I><SUB>j,[tex2html_wrap_inline1365]</SUB><I>b</I><SUP>-[tex2html_wrap_inline1366]</SUP></B></SPAN>,
then add <!-- MATH
 $d_{j,\ell}$
 -->
<SPAN CLASS="MATH"><B><I>d</I><SUB>j,[tex2html_wrap_inline1368]</SUB></B></SPAN> modulo <SPAN CLASS="MATH"><B><I>b</I></B></SPAN> to the <SPAN CLASS="MATH"><B><IMG
 ALIGN="BOTTOM" BORDER="0" SRC="overviewimg7.png"
 ALT="$ \ell$"></B></SPAN>th digit of the
digital expansion in base <SPAN CLASS="MATH"><B><I>b</I></B></SPAN> of the <SPAN CLASS="MATH"><B><I>j</I></B></SPAN>th coordinate of each point
<!-- MATH
 $\mbox{\boldmath $u$}_i\in P_n$
 -->
<SPAN CLASS="MATH"><B><SPAN CLASS="MATH"><B><I>u</I></B></SPAN><SUB>i</SUB>&#8712;<I>P</I><SUB>n</SUB></B></SPAN>.  For <SPAN CLASS="MATH"><B><I>b</I> = 2</B></SPAN>, the digit-wise addition modulo <SPAN CLASS="MATH"><B><I>b</I></B></SPAN> becomes
a bitwise exclusive-or, which is fast to perform on a computer.

<P>
An interesting property of the digital shift in base <SPAN CLASS="MATH"><B><I>b</I></B></SPAN> is that
if the hypercube <SPAN CLASS="MATH"><B>[0, 1)<SUP>s</SUP></B></SPAN> is partitioned into <!-- MATH
 $b^{q_1 + \cdots + q_s}$
 -->
<SPAN CLASS="MATH"><B><I>b</I><SUP>q<SUB>1</SUB>+<SUP> ... </SUP>+q<SUB>s</SUB></SUP></B></SPAN>
rectangular boxes
of the same size by partitioning the <SPAN CLASS="MATH"><B><I>j</I></B></SPAN>th axis into <SPAN CLASS="MATH"><B><I>b</I><SUP>q<SUB>j</SUB></SUP></B></SPAN> equal
parts for each <SPAN CLASS="MATH"><B><I>j</I></B></SPAN>, for some integers <SPAN CLASS="MATH"><B><I>q</I><SUB>j</SUB>&nbsp;&gt;=&nbsp; 0</B></SPAN>
(such a partition is called a <SPAN  CLASS="textit"><SPAN CLASS="MATH"><B><B>q</B></B></SPAN>-equidissection in base <SPAN CLASS="MATH"><B><I>b</I></B></SPAN></SPAN>
of the unit hypercube, where <!-- MATH
 $\bq = (q_1,\dots,q_s)$
 -->
<SPAN CLASS="MATH"><B><B>q</B> = (<I>q</I><SUB>1</SUB>,..., <I>q</I><SUB>s</SUB>)</B></SPAN>),  then the number of
boxes that contain <SPAN CLASS="MATH"><B><I>m</I></B></SPAN> points, for each integer <SPAN CLASS="MATH"><B><I>m</I></B></SPAN>, is unchanged by
the randomization.  In particular, if each box contains the same number
of points of <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN> before the randomization, then it also does after the
randomization.
In this case, we say that <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN> is <SPAN  CLASS="textit"><SPAN CLASS="MATH"><B><B>q</B></B></SPAN>-equidistributed in base <SPAN CLASS="MATH"><B><I>b</I></B></SPAN></SPAN>.
Several other randomization methods exist and most are adapted to
special types of point sets; see, e.g.,
 <A HREF="../../../../umontreal/iro/lecuyer/hups/DigitalNet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>DigitalNet</CODE></A> and.

<P>

<H2><A NAME="SECTION00007000000000000000">
Point set implementations and enumeration tools</A>
</H2>

<P>
Let <!-- MATH
 $\mbox{\boldmath $u$}_i = (u_{i,0}, u_{i,1}, \dots, u_{i,s-1})$
 -->
<SPAN CLASS="MATH"><B><SPAN CLASS="MATH"><B><I>u</I></B></SPAN><SUB>i</SUB> = (<I>u</I><SUB>i, 0</SUB>, <I>u</I><SUB>i, 1</SUB>,..., <I>u</I><SUB>i, s-1</SUB>)</B></SPAN>
be the elements of the point set <SPAN CLASS="MATH"><B><I>P</I><SUB>n</SUB></B></SPAN>, for <!-- MATH
 $i=0,\dots,n-1$
 -->
<SPAN CLASS="MATH"><B><I>i</I> = 0,..., <I>n</I> - 1</B></SPAN>.
Both the number of points <SPAN CLASS="MATH"><B><I>n</I></B></SPAN> and the dimension <SPAN CLASS="MATH"><B><I>s</I></B></SPAN> can be finite
or infinite.  The point set can be viewed as a two-dimensional array
whose element <SPAN CLASS="MATH"><B>(<I>i</I>, <I>j</I>)</B></SPAN> contains <SPAN CLASS="MATH"><B><I>u</I><SUB>i, j</SUB></B></SPAN>, the coordinate <SPAN CLASS="MATH"><B><I>j</I></B></SPAN> of point <SPAN CLASS="MATH"><B><I>i</I></B></SPAN>.
In the implementations of typical point sets, the values <SPAN CLASS="MATH"><B><I>u</I><SUB>i, j</SUB></B></SPAN> are
not stored explicitly in a two-dimensional array, but pertinent
information is organized so that the points and their coordinates can be
generated efficiently.  The base class for point sets is the abstract
class <A HREF="../../../../umontreal/iro/lecuyer/hups/PointSet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>PointSet</CODE></A>.

<P>
To enumerate the successive points or the successive coordinates of a
given point, we use <SPAN  CLASS="textit">point set iterators</SPAN>,
which resemble the iterators defined
in Java <SPAN  CLASS="textit">collections</SPAN>, except that they loop over bi-dimensional sets.
Their general behavior is defined in the interface
 <A HREF="../../../../umontreal/iro/lecuyer/hups/PointSetIterator.html" title="interface in umontreal.iro.lecuyer.hups"><CODE>PointSetIterator</CODE></A>.
Several independent iterators can coexist at any given time for the same
point set.  Each one maintains a current point index and a current
coordinate index, which are incremented by one when the iterator advances
to the next point or the next coordinate.  Both are initialized to 0.
Each subclass of <A HREF="../../../../umontreal/iro/lecuyer/hups/PointSet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>PointSet</CODE></A>
 has its own implementation of
<A HREF="../../../../umontreal/iro/lecuyer/hups/PointSetIterator.html" title="interface in umontreal.iro.lecuyer.hups"><CODE>PointSetIterator</CODE></A> and has
 a method <TT>iterator</TT> that
creates and returns a new point set iterator of the correct type.

<P>
An important feature of the
<A HREF="../../../../umontreal/iro/lecuyer/hups/PointSetIterator.html" title="interface in umontreal.iro.lecuyer.hups"><CODE>PointSetIterator</CODE></A> interface is that
it extends the <A HREF="../../../../umontreal/iro/lecuyer/rng/RandomStream.html" title="interface in umontreal.iro.lecuyer.rng"><CODE>RandomStream</CODE></A>
 interface.  This means that any
point set iterator can be used in place of a random stream that is
supposed to generate i.i.d. <SPAN CLASS="MATH"><B><I>U</I>(0, 1)</B></SPAN> random variables, anywhere in a
simulation program.  It then becomes very easy to replace the
(pseudo)random numbers by the coordinates <SPAN CLASS="MATH"><B><I>u</I><SUB>i, j</SUB></B></SPAN> of a randomized HUPS
without changing the internal code of the simulation program.

<P>

<H2><A NAME="SECTION00008000000000000000">
Transformed point sets and containers</A>
</H2>

<P>
HUPS are often transformed either deterministically or randomly.
Deterministic transformations can be applied to improve the uniformity,
or to eliminate some points or coordinates (i.e., selecting subsets),
or to concatenate point sets (padding), or to take an antithetic version
of a point set, etc.
Random transformations are used for randomized QMC.
They are also useful when the <SPAN  CLASS="textit">average</SPAN> of a uniformity measure
of interest over the outcomes of a certain type of randomization is
much better than the worst case and may be better than the uniformity
measure of the original point set.
When a point set is transformed, we often want to keep the original
as well, and we may want to apply different types of transformations
or different independent randomizations to the same point set.

<P>
This can be achieved via <SPAN  CLASS="textit">container</SPAN> point sets, which are defined
in terms of another point set to which they keep a reference
and apply certain transformations.
<A HREF="../../../../umontreal/iro/lecuyer/hups/ContainerPointSet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>ContainerPointSet</CODE></A> is the base
 class for such containers.
One example is <A HREF="../../../../umontreal/iro/lecuyer/hups/RandShiftedPointSet.html" title="class in umontreal.iro.lecuyer.hups"><CODE>RandShiftedPointSet</CODE></A>,
 which applies a random shift
modulo 1 to the point set that it contains.
Of course, the contained point set can be a container itself and this
can be done recursively, but too many levels of recursiveness may impair
the performance (speed).

<P>

<H2><A NAME="SECTION00009000000000000000">
Examples</A>
</H2>

<P>
To be done...
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>SSJ </b><br>V. 2.5.</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../umontreal/iro/lecuyer/gof/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../umontreal/iro/lecuyer/probdist/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?umontreal/iro/lecuyer/hups/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
To submit a bug or ask questions, send an e-mail to
        <a href="mailto:Pierre L'Ecuyer <lecuyer@IRO.UMontreal.CA>">Pierre L'Ecuyer</a>.
	
</BODY>
</HTML>
