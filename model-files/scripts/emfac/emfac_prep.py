USAGE = """

    This script is run after the Travel Model and the two post-processing scripts
    (BetweenZonesVMT.py and CreateSpeedBinsWithinZones.job).
    Typically it is run automatically by the batch file RunPrepareEmfac.bat.

    It reads the files generated by BetweenZonesVMT.py and CreateSpeedBinsWithinZones.job;
    calculates the hourly VMT fractions by speed bin and subarea;
    rescales VMT by vehicle technology to the Travel Model VMT total (using the default vehicle technology proportions in the default EMFAC template);
    outputs an excel file that is in the format of an EMFAC "custom activity template".

    The custom activity template serves as an input to EMFAC. The template generated by this script works for EMFAC version 2014.
    It should also work for EMFAC version 2017 - still to be tested though.


"""
import argparse, logging, os, pathlib, sys
import openpyxl
import openpyxl.utils.dataframe
import pandas as pd
import numpy as np

# -------------------------------------------------------------------
# Input/output file names and locations
# -------------------------------------------------------------------
CWD          = pathlib.Path.cwd()
EMFAC_PREP   = CWD / "emfac_prep"
RUN_ID       = CWD.name
OUTPUT_EXCEL = EMFAC_PREP / f"ready4emfac_{RUN_ID}_new.xlsx"
LOG_FILE     = EMFAC_PREP / f"emfac_prep.log"

# These are the max speed for the row, so speed < [this value]
# TODO: It would be less error prone if these were just in the input files rather than recoded here
SPEED_BIN_TO_LABEL = [
    [ 1,  "5mph"],
    [ 2, "10mph"],
    [ 3, "15mph"],
    [ 4, "20mph"],
    [ 5, "25mph"],
    [ 6, "30mph"],
    [ 7, "35mph"],
    [ 8, "40mph"],
    [ 9, "45mph"],
    [10, "50mph"],
    [11, "55mph"],
    [12, "60mph"],
    [13, "65mph"],
    [14, "70mph"],
    [15, "75mph"],
    [16, "80mph"],
    [17, "85mph"],
    [18, "90mph"],
]
SPEED_BIN_TO_LABEL_DF = pd.DataFrame.from_records(SPEED_BIN_TO_LABEL, columns=['speedBin','speedBin_label'])

# Mapping from county to Air Basin number
# https://ww2.arb.ca.gov/applications/emissions-air-basin
# SF = San Francisco Bay Area
# SV = Sacramento Valley
# NC = North Coast
COUNTY_GAI_AIRBASIN = [
    # countyName        GAI (geographic index)  AirBasin
    ["Alameda",         39,                     "SF"],
    ["Contra Costa",    40,                     "SF"],
    ["Marin",           41,                     "SF"],
    ["Napa",            42,                     "SF"],
    ["San Francisco",   43,                     "SF"],
    ["San Mateo",       44,                     "SF"],
    ["Santa Clara",     45,                     "SF"],
    ["Solano",          46,                     "SF"],
    ["Solano",          33,                     "SV"],
    ["Sonoma",          47,                     "SF"],
    ["Sonoma",          22,                     "NC"]
]
COUNTY_GAI_AIRBASIN_DF = pd.DataFrame.from_records(COUNTY_GAI_AIRBASIN, columns=['countyName', 'GAI', 'AirBasin'])

# The Travel Model doesn't have the concept of Veh_Tech, so
# - For the following 9 technologies, use the travel model's hourly fraction
# - For the rest, keep the default hourly fraction from the EMFAC template
USE_TRAVEL_MODEL_VMT_FOR_VEH_TECH = [
    'LDA - Dsl',
    'LDA - Gas',
    'LDT1 - Dsl',
    'LDT1 - Gas',
    'LDT2 - Dsl',
    'LDT2 - Gas',
    'MCY - Gas',
    'MDV - Dsl',
    'MDV - Gas'
]

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=USAGE)
    parser.add_argument("emfac_input_template_xslx", help="EMFAC input template")
    args = parser.parse_args()

    # create logger
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    # console handler
    ch = logging.StreamHandler()
    ch.setLevel(logging.INFO)
    ch.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p'))
    logger.addHandler(ch)
    # file handler
    fh = logging.FileHandler(LOG_FILE, mode='w')
    fh.setLevel(logging.DEBUG)
    fh.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p'))
    logger.addHandler(fh)

    logging.info("args: {}".format(args))
    logging.info(f"RUN_ID={RUN_ID}")
    logging.info(f"OUTPUT_EXCEL={OUTPUT_EXCEL}")
    logging.debug("SPEED_BIN_TO_LABEL_DF:\n{}".format(SPEED_BIN_TO_LABEL_DF))
    logging.debug("COUNTY_GAI_AIRBASIN_DF:\n{}".format(COUNTY_GAI_AIRBASIN_DF))
    # -------------------------------------------------------------------
    # Read the output csv files from Cube (CreateSpeedBinsBetweenZones and CreateSpeedBinsWithinZones) and reshape them
    # -------------------------------------------------------------------
    logging.info("=====================================================")
    logging.info("Reading modelled VMT csv files from Cube scripts")
    logging.info("=====================================================")

    # read in between zones VMT and intrazonal VMT
    BetweenZones_df = pd.read_csv(EMFAC_PREP / "CreateSpeedBinsBetweenZones_sums.csv")
    WithinZones_df  = pd.read_csv(EMFAC_PREP / "CreateSpeedBinsWithinZones_sums.csv")

    # what is the format of these VMT files?
    # rows    = countyName (9 counties + 1 external) x speed bin (13) + header (1) = 10 x 13 + 1 = 131
    # (in the future, rows = AirBasinName (11 airbains + 1 external) x speed bin (18) + header (1) = 12 x 18 + 1 = 217)
    # columns = 24 hours + 3 index columns (countyName, arbCounty, speedBin) = 27

    numLine_Between = len(BetweenZones_df)
    logging.info(f"  Finished reading CreateSpeedBinsBetweenZones_sums.csv; Read {numLine_Between} rows")
    # strip spaces from column names
    BetweenZones_df.columns = BetweenZones_df.columns.str.replace(" ","")
    # set index columns
    BetweenZones_df.set_index(["countyName","arbCounty","speedBin"], inplace=True)
    logging.debug("head:\n{}".format(BetweenZones_df.head()))

    numLine_Within = len(WithinZones_df.index)
    logging.debug(f"Finished reading CreateSpeedBinsWithinZones_sums.csv; Read {numLine_Within} rows")
    # strip spaces from column names
    WithinZones_df.columns = WithinZones_df.columns.str.replace(" ","")
    # convert arbCounty and speedBin to int
    WithinZones_df["arbCounty"] = WithinZones_df["arbCounty"].astype(int)
    WithinZones_df["speedBin"] = WithinZones_df["speedBin"].astype(int)
    # set index columns
    WithinZones_df.set_index(["countyName","arbCounty","speedBin"], inplace=True)
    logging.debug("head:\n{}".format(WithinZones_df.head()))

    logging.info("Start reshaping the modelled VMT data")
    # add the between zones VMT and intrazonal VMT together
    VMT_df = BetweenZones_df.add(WithinZones_df, fill_value=0)
    HOUR_LIST = VMT_df.columns.to_list()
    logging.debug("VMT_df.head:\n{}".format(VMT_df.head()))
    logging.info("HOUR_LIST={}".format(HOUR_LIST))

    # drop external VMT. arbCounty is index level 1
    VMT_df_len = len(VMT_df)
    VMT_df = VMT_df.loc[VMT_df.index.get_level_values(1) != 9999]
    logging.info("Dropped external VMT; rows changed from {} to {}".format(VMT_df_len, len(VMT_df)))

    # reset index
    VMT_df.reset_index(drop=False, inplace=True)
    # drop arbCounty
    VMT_df.drop(columns=['arbCounty'], inplace=True)
    logging.debug("VMT_df.head:\n{}".format(VMT_df.head()))
    countyName_list = VMT_df['countyName'].unique().tolist()
    logging.info("countyName_list: {}".format(countyName_list))

    # VMT_df has countyName x speedBin but the speedBins might be short
    # so expand to full speedBins by creating countyName x speedBim list
    speed_bin_label_by_county_df = pd.merge(
        VMT_df[['countyName']].drop_duplicates(),
        SPEED_BIN_TO_LABEL_DF,
        how="cross"
    )
    logging.debug("speed_bin_label_by_county_df:\n{}".format(speed_bin_label_by_county_df))

    # fill out VMT_df this way
    VMT_df = pd.merge(
        left  = speed_bin_label_by_county_df,
        right = VMT_df,
        how   = 'outer',
        on    = ['speedBin','countyName']
    )
    # fill in missing values
    fill_vals = {hour_label:0.0 for hour_label in HOUR_LIST}
    VMT_df.fillna(value=fill_vals, inplace=True)
    logging.debug("VMT_df:\n{}".format(VMT_df))

    # join with GAI, AirBasin
    # this will create duplicates for Sonoma and Solano, which both straddle two Air Basins
    VMT_df = pd.merge(
        left     = COUNTY_GAI_AIRBASIN_DF,
        right    = VMT_df,
        how      = 'right',
        on       = 'countyName',
    )
    logging.debug("VMT_df:\n{}".format(VMT_df))
    logging.debug("VMT_df.tail(30):\n{}".format(VMT_df.tail(30)))
    # columns are: countyName, speedBin, speedBin_label, hour[01-24]
    # change to: countyName, Hour; moving speedBin_label to columns
    VMT_df.drop(columns=['speedBin'], inplace=True)
    # convert to long: columns: countyName, GAI, AirBasin, speedBin_Label, hour, VMT
    VMT_df = pd.melt(
        VMT_df,
        id_vars=['countyName','GAI','AirBasin','speedBin_label'], 
        var_name='hour',
        value_name='VMT')
    VMT_df['hour'] = VMT_df.hour.str[4:].astype(int)
    logging.debug("long VMT_df:\n{}".format(VMT_df))
    # pivot to wide with speedBin_label as columns
    VMT_df = pd.pivot(
        VMT_df,
        columns='speedBin_label',
        index=['countyName','GAI','AirBasin','hour'])
    # columns have two levels: VMT, speedBin_label -- only need one
    VMT_df.columns = VMT_df.columns.get_level_values(1)
    VMT_df.columns.name = None
    # use sort order in SPEED_BIN_TO_LABEL_DF
    VMT_df = VMT_df[SPEED_BIN_TO_LABEL_DF.speedBin_label.tolist()]
    logging.debug("reshaped VMT_df:\n{}".format(VMT_df))

    # total vmt by hour
    VMT_df['HourlyTotalVMT'] = VMT_df.sum(axis='columns')
    # calculate fraction of vmt by speedBin
    for speedBin_label in SPEED_BIN_TO_LABEL_DF.speedBin_label.tolist():
        VMT_df[f'HourlyFraction_{speedBin_label}'] = VMT_df[speedBin_label] / VMT_df['HourlyTotalVMT']

    # finally, reset_index. columns are now countyName, GAI, AirBasin, hour, [speedBin_label list], [HourlyFraction_speedBin_label] 
    VMT_df.reset_index(drop=False, inplace=True)
    logging.debug("VMT_df:\n{}".format(VMT_df))
    logging.debug("VMT_df columns:\n{}".format(VMT_df.columns))
    # VMT_df.to_csv(EMFAC_PREP / "VMT_df.csv", header=True, index=True)

    # -------------------------------------------------------------------
    # Reading from and writing to the EMFAC Custom Activity Template
    # Part 1: hourly fractions
    # -------------------------------------------------------------------
    logging.info("================================================================")
    logging.info("Reading from and writing to the EMFAC Custom Activity Template")
    logging.info("================================================================")

    emfac_input_xlsx_fullpath = EMFAC_PREP / args.emfac_input_template_xslx
    logging.info(f"Loading the workbook {emfac_input_xlsx_fullpath}")
    workbook = openpyxl.load_workbook(filename=emfac_input_xlsx_fullpath)
    logging.info("Workbook sheetnames: {}".format(workbook.sheetnames))

    # select the hourly fraction worksheet
    sheet = workbook["Hourly_Fraction_Veh_Tech_Speed"]

    # Want the Sub-Area column (column B) and the Hour column (column F)
    # but it seeems easier to just read all the data in this sheet
    DefaultHourlyFraction = sheet.values

    # For some reason, Column A and C have the same header "Sub-Area" and are identical in contents
    # Column C is renamed here temporarily to avoid confusion. It'll be renamed back near the end of the process,
    # to ensure that the format of the custom activity template was replicated exactly.
    sheet["C1"] = "Sub-Area2"

    # Set the first row as the headers for the DataFrame
    cols = next(DefaultHourlyFraction)
    DefaultHourlyFraction = list(DefaultHourlyFraction)

    DefaultHourlyFraction_df = pd.DataFrame(DefaultHourlyFraction, columns=cols)
    logging.info("Finished reading <Hourly_Fraction_Veh_Tech_Speed>")
    logging.debug("DefaultHourlyFraction_df:\n{}".format(DefaultHourlyFraction_df))

    # Some further notes about the "Hourly_Fraction_Veh_Tech_Speed" worksheet:

    # The "Hourly_Fraction_Veh_Tech_Speed" is essentially a table of subarea (11) x hour (24) x speed bins (18).
    # The rows are subarea (11) x hour (24) x Veh_Tech (51)
    # The columns are the 18 speed bins, plus index columns (Sub-Area, GAI, Sub-Area, Cal_Year, Veh_Tech, Hour)

    # merge DataFrames
    TM_HourlyFraction_df = pd.merge(
        left     = DefaultHourlyFraction_df, 
        right    = VMT_df[['GAI','hour'] + 
                          [f"HourlyFraction_{speedbin}" for speedbin in SPEED_BIN_TO_LABEL_DF.speedBin_label.tolist()]], 
        left_on  = ['GAI','Hour'], 
        right_on = ['GAI','hour'], 
        how      = 'left',
        validate = 'many_to_one'
    )
    logging.debug("TM_HourlyFraction_df:\n{}".format(TM_HourlyFraction_df))
    logging.debug("TM_HourlyFraction_df.columns:\n{}".format(TM_HourlyFraction_df.columns))

    # use the TM version for those rows where Veh_Tech is in USE_TRAVEL_MODEL_VMT_FOR_VEH_TECH
    for speedbin in SPEED_BIN_TO_LABEL_DF.speedBin_label.tolist():
        TM_HourlyFraction_df.loc[ TM_HourlyFraction_df.Veh_Tech.isin(USE_TRAVEL_MODEL_VMT_FOR_VEH_TECH), speedbin] = \
            TM_HourlyFraction_df[f'HourlyFraction_{speedbin}']

    # we're done with these fields
    TM_HourlyFraction_df.drop(
        columns=['hour'] + [f"HourlyFraction_{speedbin}" for speedbin in SPEED_BIN_TO_LABEL_DF.speedBin_label.tolist()], 
        inplace=True)

    # write the data to excel
    # rename the existing "Hourly_Fraction_Veh_Tech_Speed" and add a new sheet
    logging.info("Writing Travel Model results to <Hourly_Fraction_Veh_Tech_Speed>")

    sheet.title = 'default hourly fractions'

    workbook.create_sheet('Hourly_Fraction_Veh_Tech_Speed')
    sheet = workbook['Hourly_Fraction_Veh_Tech_Speed']
    for row in openpyxl.utils.dataframe.dataframe_to_rows(TM_HourlyFraction_df, index=False, header=True):
        sheet.append(row)

    workbook.save(OUTPUT_EXCEL)
    logging.info(f"Finished writing to <Hourly_Fraction_Veh_Tech_Speed> in {OUTPUT_EXCEL}")

    # -------------------------------------------------------------------
    # Reading from and writing to the EMFAC Custom Activity Template
    # Part 2: VMT by Veh Tech
    # -------------------------------------------------------------------
    workbook = openpyxl.load_workbook(filename=OUTPUT_EXCEL)
    sheet = workbook["Daily_VMT_By_Veh_Tech"]

    logging.info("Reading in the data on the tab <Daily_VMT_By_Veh_Tech>")
    DefaultVMT = sheet.values

    # For some reason, Column A and C have the same header "Sub-Area" and are identical in contents
    # Column C is renamed here temporarily to avoid confusion. It'll be renamed back near the end of the process,
    # to ensure that the format of the custom activity template was replicated exactly.
    sheet["C1"] = "Sub-Area2"

    # Set the first row as the headers for the DataFrame
    cols = next(DefaultVMT)
    DefaultVMT = list(DefaultVMT)
    DefaultVMT_df = pd.DataFrame(DefaultVMT, columns=cols)
    logging.debug("DefaultVMT_df:\n{}".format(DefaultVMT_df))

    # rename the sheet
    sheet.title = 'CARB default VMT'

    # Calculate percent VMT by vehicle technology
    # first calculate CARB default VMT by GAI
    DefaultVMTbyGAI_df = DefaultVMT_df[['Sub-Area','GAI','New Total VMT']].groupby(['Sub-Area','GAI'], as_index=False).sum()
    # rename the 'New Total VMT' column to avoid confusion
    DefaultVMTbyGAI_df.rename(columns={"New Total VMT": "DefaultVMT_GAI"}, inplace=True)
    logging.debug("DefaultVMTbyGAI_df:\n{}".format(DefaultVMTbyGAI_df))

    # calculate TM VMT by subarea
    ModelledVMTbyGAI_df = VMT_df[['countyName','GAI','AirBasin','HourlyTotalVMT']].groupby(
        ['countyName','GAI','AirBasin'], as_index=False).sum()
    logging.debug("ModelledVMTbyGAI_df:\n{}".format(ModelledVMTbyGAI_df))
    # Note: the Solano/Sonoma VMT by GAI isn't accurate - it's duplicated
    # So need to apportion it based on the DefaultVMT split

    # merge modelled VMT and default VMT by GAI
    VMTbyGAI_df = pd.merge(
        left    = DefaultVMTbyGAI_df, 
        right   = ModelledVMTbyGAI_df, 
        on      = ['GAI'], 
        how     ='left'
    )
    logging.debug("VMTbyGAI_df:\n{}".format(VMTbyGAI_df))
    # aggregate DefaultVMT to county and merge that
    VMTbyCounty_df = VMTbyGAI_df[['countyName','DefaultVMT_GAI']].groupby(['countyName'], as_index=False).sum()
    VMTbyCounty_df.rename(columns={'DefaultVMT_GAI':'DefaultVMT_county'}, inplace=True)
    logging.debug("VMTbyCounty_df:\n{}".format(VMTbyCounty_df))
    VMTbyGAI_df = pd.merge(
        left    = VMTbyGAI_df,
        right   = VMTbyCounty_df,
        on      = ['countyName'],
        how     = 'left'
    )
    logging.debug("VMTbyGAI_df:\n{}".format(VMTbyGAI_df))
    # apportion based on share DefaultVMT for GAI / DefaultVMT for County
    VMTbyGAI_df['HourlyTotalVMT'] = VMTbyGAI_df.HourlyTotalVMT * (VMTbyGAI_df.DefaultVMT_GAI/VMTbyGAI_df.DefaultVMT_county)
    logging.debug("VMTbyGAI_df after apportioning county by GAI:\n{}".format(VMTbyGAI_df))

    # Merge it back into the original default VMT dataframe with the fuel types
    DefaultVMT_df = pd.merge(
        left    = DefaultVMT_df,
        right   = VMTbyGAI_df.drop(columns=['DefaultVMT_county']), 
        on      = ['Sub-Area','GAI'],
        how     = 'left'
    )

    # Use Default VMT shares by Veh_Tech (per GAI) and apply to the modeled VMT (per GAI) - which is called HouryTotalVMT
    DefaultVMT_df['percentVMT']   = DefaultVMT_df['New Total VMT'] / DefaultVMT_df['DefaultVMT_GAI']
    DefaultVMT_df['modelled_VMT'] = DefaultVMT_df.HourlyTotalVMT * DefaultVMT_df.percentVMT
    logging.debug("DefaultVMT_df:\n{}".format(DefaultVMT_df))
    
    # keep the relevant columns for writing to the excel file
    TM_VMT_By_Veh_Tech_df =  DefaultVMT_df[['Sub-Area', 'GAI', 'Sub-Area2', 'Cal_Year', 'Veh_Tech', 'modelled_VMT']]

    # writing to excel
    logging.info("Writing to <Daily_VMT_By_Veh_Tech>")
    workbook.create_sheet('Daily_VMT_By_Veh_Tech')
 
    sheet = workbook['Daily_VMT_By_Veh_Tech']
    for row in openpyxl.utils.dataframe.dataframe_to_rows(TM_VMT_By_Veh_Tech_df, index=False, header=True):
        sheet.append(row)

    # rename the columns by changing the cell on the sheet
    sheet["C1"] = "Sub-Area"
    sheet["D1"] = "Cal_Year"
    sheet["F1"] = "New Total VMT"

    workbook.save(OUTPUT_EXCEL)
    logging.info("Finished writing to <Daily_VMT_By_Veh_Tech>")
    # the "New Total VMT" in the tab <Daily_VMT_By_Veh_Tech> should be equal to 
    # the "between zone vmt (excluding external zones)" from BetweenZonesVMT.py 
    # plus the "within zone vmt (excluding external zones)" from CreateSpeedBinsWithinZones.job
    # note that *external zones are excluded* when checking totals


    # -------------------------------------------------------------------
    # Reading from and writing to the EMFAC Custom Activity Template
    # Part 3: add a readme
    # -------------------------------------------------------------------
    # still to do:
    # the emfac default values were replaced by Travel Model outputs via emfac_prep.py
    # other info e.g. model run name
